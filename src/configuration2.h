// generated by generate_config.js
// source file is config.js

#pragma once

#include <string>
#include <list>

class Configuration2
{
public:
	enum class Mode
	{
		Undefined = 0,
		Alsa,
		Fake,
		Jack,
	};
	struct Common
	{
		bool quiet {false};
		int sampleRate {44100};
		bool mono {false};
		bool mic {false};
		int shift {0};
		int stretch {100};
		int pitch {0};
	};
	struct Alsa : Common
	{
		std::string device {"default"};
		int periodSize {1024};
		int periods {2};
	};
	struct Fake : Common
	{
		std::string fifoPlayback {"~/.stretchplayer-playback.fifo"};
		std::string fifoCapture {"~/.stretchplayer-capture.fifo"};
		int periodSize {1024};
		int bitsPerSample {16};
	};
	struct Jack : Common
	{
		bool noAutoconnect {false};
	};
	Configuration2() = default;
	int parse(int p_argc, char **p_argv, const char *p_helpPrefix, const char *p_helpPostfix, std::string *p_error); // return value: 0 if normal player start needed; 1 - if normal exit required; -1 - if error exit required (writing error description into p_error)

	Mode mode() const {return _mode;}
	Alsa alsa() const {return _data.alsa;}
	Fake fake() const {return _data.fake;}
	Jack jack() const {return _data.jack;}

	bool quiet() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.quiet;
		else if (_mode == Mode::Fake)
			return _data.fake.quiet;
		else if (_mode == Mode::Jack)
			return _data.jack.quiet;
		return _data.jack.quiet;
	}

	int sampleRate() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.sampleRate;
		else if (_mode == Mode::Fake)
			return _data.fake.sampleRate;
		else if (_mode == Mode::Jack)
			return _data.jack.sampleRate;
		return _data.jack.sampleRate;
	}

	bool mono() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.mono;
		else if (_mode == Mode::Fake)
			return _data.fake.mono;
		else if (_mode == Mode::Jack)
			return _data.jack.mono;
		return _data.jack.mono;
	}

	bool mic() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.mic;
		else if (_mode == Mode::Fake)
			return _data.fake.mic;
		else if (_mode == Mode::Jack)
			return _data.jack.mic;
		return _data.jack.mic;
	}

	int shift() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.shift;
		else if (_mode == Mode::Fake)
			return _data.fake.shift;
		else if (_mode == Mode::Jack)
			return _data.jack.shift;
		return _data.jack.shift;
	}

	int stretch() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.stretch;
		else if (_mode == Mode::Fake)
			return _data.fake.stretch;
		else if (_mode == Mode::Jack)
			return _data.jack.stretch;
		return _data.jack.stretch;
	}

	int pitch() const
	{
		if (_mode == Mode::Alsa)
			return _data.alsa.pitch;
		else if (_mode == Mode::Fake)
			return _data.fake.pitch;
		else if (_mode == Mode::Jack)
			return _data.jack.pitch;
		return _data.jack.pitch;
	}

	std::list<std::string> argv() const
	{
		return _argv;
	}

	std::string toString() const;

private:
	class JsonParser;
	int collectError(std::string *p_error, const std::string &p_message) const;
	static std::string resolveEnvVarsAndTilda(const std::string &p);
	std::string generateConf() const;

	std::string _configPath;

	struct
	{
		Alsa alsa;
		Fake fake;
		Jack jack;
	} _data;
	Mode _mode {Mode::Undefined};
	std::list<std::string> _argv;
};